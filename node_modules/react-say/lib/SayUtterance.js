"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _Composer = _interopRequireDefault(require("./Composer"));

var _createCustomEvent = _interopRequireDefault(require("./createCustomEvent"));

var _createErrorEvent = _interopRequireDefault(require("./createErrorEvent"));

var _migrateDeprecatedProps = _interopRequireDefault(require("./migrateDeprecatedProps"));

var _useSynthesize = _interopRequireDefault(require("./useSynthesize"));

var _excluded = ["ponyfill"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var SayUtterance = function SayUtterance(props) {
  var _migrateDeprecatedPro = (0, _migrateDeprecatedProps["default"])(props),
      onEnd = _migrateDeprecatedPro.onEnd,
      onError = _migrateDeprecatedPro.onError,
      onStart = _migrateDeprecatedPro.onStart,
      utterance = _migrateDeprecatedPro.utterance;

  var started = (0, _react.useRef)(false);
  var synthesize = (0, _useSynthesize["default"])(); // This useEffect() is essentially converting Promise-based useSynthesize() into events.

  (0, _react.useEffect)(function () {
    // After synthesis started, if utterance has changed, the event will be fired by the wrong target.
    // Thus, we do not allow utterance to change after synthesis started.
    if (started.current) {
      // Since we have already cancelled the previous utterance, we are not starting a new one.
      // This is because if we start a new one, we could fire onStart event twice, which sound confusing to the developer.
      return console.warn('react-say: Should not change utterance after synthesis started.');
    }

    var cancelled;

    var _synthesize = synthesize(utterance, function () {
      started.current = true;
      !cancelled && onStart && onStart((0, _createCustomEvent["default"])('start'));
    }),
        cancel = _synthesize.cancel,
        promise = _synthesize.promise;

    promise.then(function () {
      return !cancelled && onEnd && onEnd((0, _createCustomEvent["default"])('end'));
    }, function (error) {
      return !cancelled && onError && onError((0, _createErrorEvent["default"])(error));
    });
    return function () {
      cancelled = true;
      cancel();
    };
  }, []);
  return false;
};

SayUtterance.defaultProps = {
  onEnd: undefined,
  onError: undefined,
  onStart: undefined
};
SayUtterance.propTypes = {
  onEnd: _propTypes["default"].func,
  onError: _propTypes["default"].func,
  onStart: _propTypes["default"].func
};

var SayUtteranceWithContext = function SayUtteranceWithContext(_ref) {
  var ponyfill = _ref.ponyfill,
      props = (0, _objectWithoutProperties2["default"])(_ref, _excluded);
  return /*#__PURE__*/_react["default"].createElement(_Composer["default"], {
    ponyfill: ponyfill
  }, /*#__PURE__*/_react["default"].createElement(SayUtterance, props));
};

SayUtteranceWithContext.defaultProps = _objectSpread(_objectSpread({}, SayUtterance.defaultProps), {}, {
  ponyfill: undefined
});
SayUtteranceWithContext.propTypes = _objectSpread(_objectSpread({}, SayUtterance.propTypes), {}, {
  ponyfill: _propTypes["default"].shape({
    speechSynthesis: _propTypes["default"].any.isRequired,
    SpeechSynthesisUtterance: _propTypes["default"].any.isRequired
  })
});
var _default = SayUtteranceWithContext;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TYXlVdHRlcmFuY2UuanMiXSwibmFtZXMiOlsiU2F5VXR0ZXJhbmNlIiwicHJvcHMiLCJvbkVuZCIsIm9uRXJyb3IiLCJvblN0YXJ0IiwidXR0ZXJhbmNlIiwic3RhcnRlZCIsInN5bnRoZXNpemUiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJjYW5jZWxsZWQiLCJjYW5jZWwiLCJwcm9taXNlIiwidGhlbiIsImVycm9yIiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiZnVuYyIsIlNheVV0dGVyYW5jZVdpdGhDb250ZXh0IiwicG9ueWZpbGwiLCJzaGFwZSIsInNwZWVjaFN5bnRoZXNpcyIsImFueSIsImlzUmVxdWlyZWQiLCJTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFBQyxLQUFLLEVBQUk7QUFDNUIsOEJBS0ksd0NBQXVCQSxLQUF2QixDQUxKO0FBQUEsTUFDRUMsS0FERix5QkFDRUEsS0FERjtBQUFBLE1BRUVDLE9BRkYseUJBRUVBLE9BRkY7QUFBQSxNQUdFQyxPQUhGLHlCQUdFQSxPQUhGO0FBQUEsTUFJRUMsU0FKRix5QkFJRUEsU0FKRjs7QUFPQSxNQUFNQyxPQUFPLEdBQUcsbUJBQU8sS0FBUCxDQUFoQjtBQUNBLE1BQU1DLFVBQVUsR0FBRyxnQ0FBbkIsQ0FUNEIsQ0FXNUI7O0FBQ0Esd0JBQVUsWUFBTTtBQUNkO0FBQ0E7QUFDQSxRQUFJRCxPQUFPLENBQUNFLE9BQVosRUFBcUI7QUFDbkI7QUFDQTtBQUVBLGFBQU9DLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLGlFQUFiLENBQVA7QUFDRDs7QUFFRCxRQUFJQyxTQUFKOztBQUNBLHNCQUE0QkosVUFBVSxDQUFDRixTQUFELEVBQVksWUFBTTtBQUN0REMsTUFBQUEsT0FBTyxDQUFDRSxPQUFSLEdBQWtCLElBQWxCO0FBQ0EsT0FBQ0csU0FBRCxJQUFjUCxPQUFkLElBQXlCQSxPQUFPLENBQUMsbUNBQWtCLE9BQWxCLENBQUQsQ0FBaEM7QUFDRCxLQUhxQyxDQUF0QztBQUFBLFFBQVFRLE1BQVIsZUFBUUEsTUFBUjtBQUFBLFFBQWdCQyxPQUFoQixlQUFnQkEsT0FBaEI7O0FBS0FBLElBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUNFO0FBQUEsYUFBTSxDQUFDSCxTQUFELElBQWNULEtBQWQsSUFBdUJBLEtBQUssQ0FBQyxtQ0FBa0IsS0FBbEIsQ0FBRCxDQUFsQztBQUFBLEtBREYsRUFFRSxVQUFBYSxLQUFLO0FBQUEsYUFBSSxDQUFDSixTQUFELElBQWNSLE9BQWQsSUFBeUJBLE9BQU8sQ0FBQyxrQ0FBaUJZLEtBQWpCLENBQUQsQ0FBcEM7QUFBQSxLQUZQO0FBS0EsV0FBTyxZQUFNO0FBQ1hKLE1BQUFBLFNBQVMsR0FBRyxJQUFaO0FBQ0FDLE1BQUFBLE1BQU07QUFDUCxLQUhEO0FBSUQsR0F6QkQsRUF5QkcsRUF6Qkg7QUEyQkEsU0FBTyxLQUFQO0FBQ0QsQ0F4Q0Q7O0FBMENBWixZQUFZLENBQUNnQixZQUFiLEdBQTRCO0FBQzFCZCxFQUFBQSxLQUFLLEVBQUVlLFNBRG1CO0FBRTFCZCxFQUFBQSxPQUFPLEVBQUVjLFNBRmlCO0FBRzFCYixFQUFBQSxPQUFPLEVBQUVhO0FBSGlCLENBQTVCO0FBTUFqQixZQUFZLENBQUNrQixTQUFiLEdBQXlCO0FBQ3ZCaEIsRUFBQUEsS0FBSyxFQUFFaUIsc0JBQVVDLElBRE07QUFFdkJqQixFQUFBQSxPQUFPLEVBQUVnQixzQkFBVUMsSUFGSTtBQUd2QmhCLEVBQUFBLE9BQU8sRUFBRWUsc0JBQVVDO0FBSEksQ0FBekI7O0FBTUEsSUFBTUMsdUJBQXVCLEdBQUcsU0FBMUJBLHVCQUEwQjtBQUFBLE1BQUdDLFFBQUgsUUFBR0EsUUFBSDtBQUFBLE1BQWdCckIsS0FBaEI7QUFBQSxzQkFDOUIsZ0NBQUMsb0JBQUQ7QUFBVSxJQUFBLFFBQVEsRUFBR3FCO0FBQXJCLGtCQUNFLGdDQUFDLFlBQUQsRUFBbUJyQixLQUFuQixDQURGLENBRDhCO0FBQUEsQ0FBaEM7O0FBTUFvQix1QkFBdUIsQ0FBQ0wsWUFBeEIsbUNBQ0toQixZQUFZLENBQUNnQixZQURsQjtBQUVFTSxFQUFBQSxRQUFRLEVBQUVMO0FBRlo7QUFLQUksdUJBQXVCLENBQUNILFNBQXhCLG1DQUNLbEIsWUFBWSxDQUFDa0IsU0FEbEI7QUFFRUksRUFBQUEsUUFBUSxFQUFFSCxzQkFBVUksS0FBVixDQUFnQjtBQUN4QkMsSUFBQUEsZUFBZSxFQUFFTCxzQkFBVU0sR0FBVixDQUFjQyxVQURQO0FBRXhCQyxJQUFBQSx3QkFBd0IsRUFBRVIsc0JBQVVNLEdBQVYsQ0FBY0M7QUFGaEIsR0FBaEI7QUFGWjtlQVFlTCx1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBDb21wb3NlciBmcm9tICcuL0NvbXBvc2VyJztcbmltcG9ydCBjcmVhdGVDdXN0b21FdmVudCBmcm9tICcuL2NyZWF0ZUN1c3RvbUV2ZW50JztcbmltcG9ydCBjcmVhdGVFcnJvckV2ZW50IGZyb20gJy4vY3JlYXRlRXJyb3JFdmVudCc7XG5pbXBvcnQgbWlncmF0ZURlcHJlY2F0ZWRQcm9wcyBmcm9tICcuL21pZ3JhdGVEZXByZWNhdGVkUHJvcHMnO1xuaW1wb3J0IHVzZVN5bnRoZXNpemUgZnJvbSAnLi91c2VTeW50aGVzaXplJztcblxuY29uc3QgU2F5VXR0ZXJhbmNlID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgb25FbmQsXG4gICAgb25FcnJvcixcbiAgICBvblN0YXJ0LFxuICAgIHV0dGVyYW5jZVxuICB9ID0gbWlncmF0ZURlcHJlY2F0ZWRQcm9wcyhwcm9wcyk7XG5cbiAgY29uc3Qgc3RhcnRlZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHN5bnRoZXNpemUgPSB1c2VTeW50aGVzaXplKCk7XG5cbiAgLy8gVGhpcyB1c2VFZmZlY3QoKSBpcyBlc3NlbnRpYWxseSBjb252ZXJ0aW5nIFByb21pc2UtYmFzZWQgdXNlU3ludGhlc2l6ZSgpIGludG8gZXZlbnRzLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEFmdGVyIHN5bnRoZXNpcyBzdGFydGVkLCBpZiB1dHRlcmFuY2UgaGFzIGNoYW5nZWQsIHRoZSBldmVudCB3aWxsIGJlIGZpcmVkIGJ5IHRoZSB3cm9uZyB0YXJnZXQuXG4gICAgLy8gVGh1cywgd2UgZG8gbm90IGFsbG93IHV0dGVyYW5jZSB0byBjaGFuZ2UgYWZ0ZXIgc3ludGhlc2lzIHN0YXJ0ZWQuXG4gICAgaWYgKHN0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBhbHJlYWR5IGNhbmNlbGxlZCB0aGUgcHJldmlvdXMgdXR0ZXJhbmNlLCB3ZSBhcmUgbm90IHN0YXJ0aW5nIGEgbmV3IG9uZS5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBpZiB3ZSBzdGFydCBhIG5ldyBvbmUsIHdlIGNvdWxkIGZpcmUgb25TdGFydCBldmVudCB0d2ljZSwgd2hpY2ggc291bmQgY29uZnVzaW5nIHRvIHRoZSBkZXZlbG9wZXIuXG5cbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ3JlYWN0LXNheTogU2hvdWxkIG5vdCBjaGFuZ2UgdXR0ZXJhbmNlIGFmdGVyIHN5bnRoZXNpcyBzdGFydGVkLicpO1xuICAgIH1cblxuICAgIGxldCBjYW5jZWxsZWQ7XG4gICAgY29uc3QgeyBjYW5jZWwsIHByb21pc2UgfSA9IHN5bnRoZXNpemUodXR0ZXJhbmNlLCAoKSA9PiB7XG4gICAgICBzdGFydGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgIWNhbmNlbGxlZCAmJiBvblN0YXJ0ICYmIG9uU3RhcnQoY3JlYXRlQ3VzdG9tRXZlbnQoJ3N0YXJ0JykpO1xuICAgIH0pO1xuXG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKCkgPT4gIWNhbmNlbGxlZCAmJiBvbkVuZCAmJiBvbkVuZChjcmVhdGVDdXN0b21FdmVudCgnZW5kJykpLFxuICAgICAgZXJyb3IgPT4gIWNhbmNlbGxlZCAmJiBvbkVycm9yICYmIG9uRXJyb3IoY3JlYXRlRXJyb3JFdmVudChlcnJvcikpXG4gICAgKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblNheVV0dGVyYW5jZS5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uRW5kOiB1bmRlZmluZWQsXG4gIG9uRXJyb3I6IHVuZGVmaW5lZCxcbiAgb25TdGFydDogdW5kZWZpbmVkXG59O1xuXG5TYXlVdHRlcmFuY2UucHJvcFR5cGVzID0ge1xuICBvbkVuZDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICBvblN0YXJ0OiBQcm9wVHlwZXMuZnVuY1xufTtcblxuY29uc3QgU2F5VXR0ZXJhbmNlV2l0aENvbnRleHQgPSAoeyBwb255ZmlsbCwgLi4ucHJvcHMgfSkgPT4gKFxuICA8Q29tcG9zZXIgcG9ueWZpbGw9eyBwb255ZmlsbCB9PlxuICAgIDxTYXlVdHRlcmFuY2UgeyAuLi5wcm9wcyB9IC8+XG4gIDwvQ29tcG9zZXI+XG4pO1xuXG5TYXlVdHRlcmFuY2VXaXRoQ29udGV4dC5kZWZhdWx0UHJvcHMgPSB7XG4gIC4uLlNheVV0dGVyYW5jZS5kZWZhdWx0UHJvcHMsXG4gIHBvbnlmaWxsOiB1bmRlZmluZWRcbn07XG5cblNheVV0dGVyYW5jZVdpdGhDb250ZXh0LnByb3BUeXBlcyA9IHtcbiAgLi4uU2F5VXR0ZXJhbmNlLnByb3BUeXBlcyxcbiAgcG9ueWZpbGw6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgc3BlZWNoU3ludGhlc2lzOiBQcm9wVHlwZXMuYW55LmlzUmVxdWlyZWQsXG4gICAgU3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlOiBQcm9wVHlwZXMuYW55LmlzUmVxdWlyZWRcbiAgfSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNheVV0dGVyYW5jZVdpdGhDb250ZXh0XG4iXX0=