"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _readOnlyError2 = _interopRequireDefault(require("@babel/runtime/helpers/readOnlyError"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _Composer = _interopRequireDefault(require("./Composer"));

var _Context = _interopRequireDefault(require("./Context"));

var _createNativeUtterance = _interopRequireDefault(require("./createNativeUtterance"));

var _migrateDeprecatedProps = _interopRequireDefault(require("./migrateDeprecatedProps"));

var _SayUtterance = _interopRequireDefault(require("./SayUtterance"));

var _excluded = ["ponyfill"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Say = function Say(props) {
  var _migrateDeprecatedPro = (0, _migrateDeprecatedProps["default"])(props, Say),
      lang = _migrateDeprecatedPro.lang,
      onBoundary = _migrateDeprecatedPro.onBoundary,
      onEnd = _migrateDeprecatedPro.onEnd,
      onError = _migrateDeprecatedPro.onError,
      onStart = _migrateDeprecatedPro.onStart,
      pitch = _migrateDeprecatedPro.pitch,
      rate = _migrateDeprecatedPro.rate,
      speak = _migrateDeprecatedPro.speak,
      text = _migrateDeprecatedPro.text,
      voice = _migrateDeprecatedPro.voice,
      volume = _migrateDeprecatedPro.volume;

  var _useContext = (0, _react.useContext)(_Context["default"]),
      ponyfill = _useContext.ponyfill;

  if (speak && !text) {
    console.warn('react-say: "speak" prop is being deprecated and renamed to "text".');
    speak, (0, _readOnlyError2["default"])("text");
  }

  var utterance = (0, _react.useMemo)(function () {
    return (0, _createNativeUtterance["default"])(ponyfill, {
      lang: lang,
      onBoundary: onBoundary,
      pitch: pitch,
      rate: rate,
      text: text,
      voice: voice,
      volume: volume
    });
  }, [lang, onBoundary, pitch, ponyfill, rate, text, voice, volume]);
  return /*#__PURE__*/_react["default"].createElement(_SayUtterance["default"], {
    onEnd: onEnd,
    onError: onError,
    onStart: onStart,
    ponyfill: ponyfill,
    utterance: utterance
  });
};

Say.defaultProps = {
  children: undefined,
  lang: undefined,
  onBoundary: undefined,
  onEnd: undefined,
  onError: undefined,
  onStart: undefined,
  pitch: undefined,
  rate: undefined,
  speak: undefined,
  voice: undefined,
  volume: undefined
};
Say.propTypes = {
  children: _propTypes["default"].any,
  lang: _propTypes["default"].string,
  onBoundary: _propTypes["default"].func,
  onEnd: _propTypes["default"].func,
  onError: _propTypes["default"].func,
  onStart: _propTypes["default"].func,
  pitch: _propTypes["default"].number,
  rate: _propTypes["default"].number,
  speak: _propTypes["default"].string,
  text: _propTypes["default"].string.isRequired,
  voice: _propTypes["default"].oneOfType([_propTypes["default"].any, _propTypes["default"].func]),
  volume: _propTypes["default"].number
};

var SayWithContext = function SayWithContext(_ref) {
  var ponyfill = _ref.ponyfill,
      props = (0, _objectWithoutProperties2["default"])(_ref, _excluded);
  return /*#__PURE__*/_react["default"].createElement(_Composer["default"], {
    ponyfill: ponyfill
  }, /*#__PURE__*/_react["default"].createElement(Say, props));
};

SayWithContext.defaultProps = _objectSpread(_objectSpread({}, _SayUtterance["default"].defaultProps), {}, {
  ponyfill: undefined
});
SayWithContext.propTypes = _objectSpread(_objectSpread({}, _SayUtterance["default"].propTypes), {}, {
  ponyfill: _propTypes["default"].shape({
    speechSynthesis: _propTypes["default"].any.isRequired,
    SpeechSynthesisUtterance: _propTypes["default"].any.isRequired
  })
});
var _default = SayWithContext;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TYXkuanMiXSwibmFtZXMiOlsiU2F5IiwicHJvcHMiLCJsYW5nIiwib25Cb3VuZGFyeSIsIm9uRW5kIiwib25FcnJvciIsIm9uU3RhcnQiLCJwaXRjaCIsInJhdGUiLCJzcGVhayIsInRleHQiLCJ2b2ljZSIsInZvbHVtZSIsIkNvbnRleHQiLCJwb255ZmlsbCIsImNvbnNvbGUiLCJ3YXJuIiwidXR0ZXJhbmNlIiwiZGVmYXVsdFByb3BzIiwiY2hpbGRyZW4iLCJ1bmRlZmluZWQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJhbnkiLCJzdHJpbmciLCJmdW5jIiwibnVtYmVyIiwiaXNSZXF1aXJlZCIsIm9uZU9mVHlwZSIsIlNheVdpdGhDb250ZXh0IiwiU2F5VXR0ZXJhbmNlIiwic2hhcGUiLCJzcGVlY2hTeW50aGVzaXMiLCJTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLEdBQUcsR0FBRyxTQUFOQSxHQUFNLENBQUFDLEtBQUssRUFBSTtBQUNuQiw4QkFZSSx3Q0FBdUJBLEtBQXZCLEVBQThCRCxHQUE5QixDQVpKO0FBQUEsTUFDRUUsSUFERix5QkFDRUEsSUFERjtBQUFBLE1BRUVDLFVBRkYseUJBRUVBLFVBRkY7QUFBQSxNQUdFQyxLQUhGLHlCQUdFQSxLQUhGO0FBQUEsTUFJRUMsT0FKRix5QkFJRUEsT0FKRjtBQUFBLE1BS0VDLE9BTEYseUJBS0VBLE9BTEY7QUFBQSxNQU1FQyxLQU5GLHlCQU1FQSxLQU5GO0FBQUEsTUFPRUMsSUFQRix5QkFPRUEsSUFQRjtBQUFBLE1BUUVDLEtBUkYseUJBUUVBLEtBUkY7QUFBQSxNQVNFQyxJQVRGLHlCQVNFQSxJQVRGO0FBQUEsTUFVRUMsS0FWRix5QkFVRUEsS0FWRjtBQUFBLE1BV0VDLE1BWEYseUJBV0VBLE1BWEY7O0FBY0Es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Q1gsWUFBZixtQ0FDS1kseUJBQWFaLFlBRGxCO0FBRUVKLEVBQUFBLFFBQVEsRUFBRU07QUFGWjtBQUtBUyxjQUFjLENBQUNSLFNBQWYsbUNBQ0tTLHlCQUFhVCxTQURsQjtBQUVFUCxFQUFBQSxRQUFRLEVBQUVRLHNCQUFVUyxLQUFWLENBQWdCO0FBQ3hCQyxJQUFBQSxlQUFlLEVBQUVWLHNCQUFVQyxHQUFWLENBQWNJLFVBRFA7QUFFeEJNLElBQUFBLHdCQUF3QixFQUFFWCxzQkFBVUMsR0FBVixDQUFjSTtBQUZoQixHQUFoQjtBQUZaO2VBUWVFLGMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBDb21wb3NlciBmcm9tICcuL0NvbXBvc2VyJztcbmltcG9ydCBDb250ZXh0IGZyb20gJy4vQ29udGV4dCc7XG5pbXBvcnQgY3JlYXRlTmF0aXZlVXR0ZXJhbmNlIGZyb20gJy4vY3JlYXRlTmF0aXZlVXR0ZXJhbmNlJztcbmltcG9ydCBtaWdyYXRlRGVwcmVjYXRlZFByb3BzIGZyb20gJy4vbWlncmF0ZURlcHJlY2F0ZWRQcm9wcyc7XG5pbXBvcnQgU2F5VXR0ZXJhbmNlIGZyb20gJy4vU2F5VXR0ZXJhbmNlJztcblxuY29uc3QgU2F5ID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgbGFuZyxcbiAgICBvbkJvdW5kYXJ5LFxuICAgIG9uRW5kLFxuICAgIG9uRXJyb3IsXG4gICAgb25TdGFydCxcbiAgICBwaXRjaCxcbiAgICByYXRlLFxuICAgIHNwZWFrLFxuICAgIHRleHQsXG4gICAgdm9pY2UsXG4gICAgdm9sdW1lXG4gIH0gPSBtaWdyYXRlRGVwcmVjYXRlZFByb3BzKHByb3BzLCBTYXkpO1xuXG4gIGNvbnN0IHsgcG9ueWZpbGwgfSA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG5cbiAgaWYgKHNwZWFrICYmICF0ZXh0KSB7XG4gICAgY29uc29sZS53YXJuKCdyZWFjdC1zYXk6IFwic3BlYWtcIiBwcm9wIGlzIGJlaW5nIGRlcHJlY2F0ZWQgYW5kIHJlbmFtZWQgdG8gXCJ0ZXh0XCIuJyk7XG4gICAgdGV4dCA9IHNwZWFrO1xuICB9XG5cbiAgY29uc3QgdXR0ZXJhbmNlID0gdXNlTWVtbygoKSA9PlxuICAgIGNyZWF0ZU5hdGl2ZVV0dGVyYW5jZShcbiAgICAgIHBvbnlmaWxsLFxuICAgICAge1xuICAgICAgICBsYW5nLFxuICAgICAgICBvbkJvdW5kYXJ5LFxuICAgICAgICBwaXRjaCxcbiAgICAgICAgcmF0ZSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgdm9pY2UsXG4gICAgICAgIHZvbHVtZVxuICAgICAgfVxuICAgICksXG4gICAgW1xuICAgICAgbGFuZyxcbiAgICAgIG9uQm91bmRhcnksXG4gICAgICBwaXRjaCxcbiAgICAgIHBvbnlmaWxsLFxuICAgICAgcmF0ZSxcbiAgICAgIHRleHQsXG4gICAgICB2b2ljZSxcbiAgICAgIHZvbHVtZVxuICAgIF1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxTYXlVdHRlcmFuY2VcbiAgICAgIG9uRW5kPXsgb25FbmQgfVxuICAgICAgb25FcnJvcj17IG9uRXJyb3IgfVxuICAgICAgb25TdGFydD17IG9uU3RhcnQgfVxuICAgICAgcG9ueWZpbGw9eyBwb255ZmlsbCB9XG4gICAgICB1dHRlcmFuY2U9eyB1dHRlcmFuY2UgfVxuICAgIC8+XG4gICk7XG59XG5cblNheS5kZWZhdWx0UHJvcHMgPSB7XG4gIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gIGxhbmc6IHVuZGVmaW5lZCxcbiAgb25Cb3VuZGFyeTogdW5kZWZpbmVkLFxuICBvbkVuZDogdW5kZWZpbmVkLFxuICBvbkVycm9yOiB1bmRlZmluZWQsXG4gIG9uU3RhcnQ6IHVuZGVmaW5lZCxcbiAgcGl0Y2g6IHVuZGVmaW5lZCxcbiAgcmF0ZTogdW5kZWZpbmVkLFxuICBzcGVhazogdW5kZWZpbmVkLFxuICB2b2ljZTogdW5kZWZpbmVkLFxuICB2b2x1bWU6IHVuZGVmaW5lZFxufTtcblxuU2F5LnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gIGxhbmc6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9uQm91bmRhcnk6IFByb3BUeXBlcy5mdW5jLFxuICBvbkVuZDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICBvblN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJhdGU6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNwZWFrOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0ZXh0OiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHZvaWNlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYW55LCBQcm9wVHlwZXMuZnVuY10pLFxuICB2b2x1bWU6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbmNvbnN0IFNheVdpdGhDb250ZXh0ID0gKHsgcG9ueWZpbGwsIC4uLnByb3BzIH0pID0+IChcbiAgPENvbXBvc2VyIHBvbnlmaWxsPXsgcG9ueWZpbGwgfT5cbiAgICA8U2F5IHsuLi5wcm9wc30gLz5cbiAgPC9Db21wb3Nlcj5cbik7XG5cblNheVdpdGhDb250ZXh0LmRlZmF1bHRQcm9wcyA9IHtcbiAgLi4uU2F5VXR0ZXJhbmNlLmRlZmF1bHRQcm9wcyxcbiAgcG9ueWZpbGw6IHVuZGVmaW5lZFxufTtcblxuU2F5V2l0aENvbnRleHQucHJvcFR5cGVzID0ge1xuICAuLi5TYXlVdHRlcmFuY2UucHJvcFR5cGVzLFxuICBwb255ZmlsbDogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBzcGVlY2hTeW50aGVzaXM6IFByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZCxcbiAgICBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2U6IFByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZFxuICB9KVxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2F5V2l0aENvbnRleHRcbiJdfQ==