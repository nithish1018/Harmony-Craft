"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _Context = _interopRequireDefault(require("./Context"));

var _createSynthesize = _interopRequireDefault(require("./createSynthesize"));

var _migrateDeprecatedProps = _interopRequireDefault(require("./migrateDeprecatedProps"));

var _useEvent = _interopRequireDefault(require("./useEvent"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Composer = function Composer(props) {
  var _migrateDeprecatedPro = (0, _migrateDeprecatedProps["default"])(props, Composer),
      children = _migrateDeprecatedPro.children,
      ponyfillFromProps = _migrateDeprecatedPro.ponyfill; // If we have the parent context, we will use that synthesize() function and its internal queue.


  var _ref = (0, _react.useContext)(_Context["default"]) || {},
      parentPonyfill = _ref.ponyfill,
      parentSynthesize = _ref.synthesize;

  var ponyfill = ponyfillFromProps || parentPonyfill || {
    speechSynthesis: window.speechSynthesis || window.webkitSpeechSynthesis,
    SpeechSynthesisUtterance: window.SpeechSynthesisUtterance || window.webkitSpeechSynthesisUtterance
  }; // If the parent context changed and no longer has a synthesize() function, we will create the queue.
  // This is very unlikely to happen.

  var synthesize = (0, _react.useMemo)(function () {
    return parentSynthesize || (0, _createSynthesize["default"])();
  }, [parentSynthesize]);
  var speechSynthesis = ponyfill.speechSynthesis;

  var _useState = (0, _react.useState)(speechSynthesis.getVoices()),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      voices = _useState2[0],
      setVoices = _useState2[1];

  (0, _useEvent["default"])(speechSynthesis, 'voiceschanged', function () {
    return setVoices(speechSynthesis.getVoices());
  });
  var context = (0, _react.useMemo)(function () {
    return {
      ponyfill: ponyfill,
      synthesize: synthesize,
      voices: voices
    };
  }, [ponyfill, synthesize, voices]);
  return /*#__PURE__*/_react["default"].createElement(_Context["default"].Provider, {
    value: context
  }, typeof children === 'function' ? /*#__PURE__*/_react["default"].createElement(_Context["default"].Consumer, null, function (context) {
    return children(context);
  }) : children);
};

Composer.defaultProps = {
  children: undefined,
  ponyfill: undefined
};
Composer.propTypes = {
  children: _propTypes["default"].any,
  ponyfill: _propTypes["default"].shape({
    speechSynthesis: _propTypes["default"].any,
    SpeechSynthesisUtterance: _propTypes["default"].any
  })
};
var _default = Composer;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJDb21wb3NlciIsInByb3BzIiwiY2hpbGRyZW4iLCJwb255ZmlsbEZyb21Qcm9wcyIsInBvbnlmaWxsIiwiQ29udGV4dCIsInBhcmVudFBvbnlmaWxsIiwicGFyZW50U3ludGhlc2l6ZSIsInN5bnRoZXNpemUiLCJzcGVlY2hTeW50aGVzaXMiLCJ3aW5kb3ciLCJ3ZWJraXRTcGVlY2hTeW50aGVzaXMiLCJTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UiLCJ3ZWJraXRTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UiLCJnZXRWb2ljZXMiLCJ2b2ljZXMiLCJzZXRWb2ljZXMiLCJjb250ZXh0IiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiYW55Iiwic2hhcGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsUUFBUSxHQUFHLFNBQVhBLFFBQVcsQ0FBQUMsS0FBSyxFQUFJO0FBQ3hCLDhCQUFrRCx3Q0FBdUJBLEtBQXZCLEVBQThCRCxRQUE5QixDQUFsRDtBQUFBLE1BQVFFLFFBQVIseUJBQVFBLFFBQVI7QUFBQSxNQUE0QkMsaUJBQTVCLHlCQUFrQkMsUUFBbEIsQ0FEd0IsQ0FHeEI7OztBQUNBLGFBQW1FLHVCQUFXQyxtQkFBWCxLQUF1QixFQUExRjtBQUFBLE1BQWtCQyxjQUFsQixRQUFRRixRQUFSO0FBQUEsTUFBOENHLGdCQUE5QyxRQUFrQ0MsVUFBbEM7O0FBRUEsTUFBTUosUUFBUSxHQUFHRCxpQkFBaUIsSUFBSUcsY0FBckIsSUFBdUM7QUFDdERHLElBQUFBLGVBQWUsRUFBRUMsTUFBTSxDQUFDRCxlQUFQLElBQTBCQyxNQUFNLENBQUNDLHFCQURJO0FBRXREQyxJQUFBQSx3QkFBd0IsRUFBRUYsTUFBTSxDQUFDRSx3QkFBUCxJQUFtQ0YsTUFBTSxDQUFDRztBQUZkLEdBQXhELENBTndCLENBV3hCO0FBQ0E7O0FBQ0EsTUFBTUwsVUFBVSxHQUFHLG9CQUFRO0FBQUEsV0FBTUQsZ0JBQWdCLElBQUksbUNBQTFCO0FBQUEsR0FBUixFQUFzRCxDQUFDQSxnQkFBRCxDQUF0RCxDQUFuQjtBQUNBLE1BQVFFLGVBQVIsR0FBNEJMLFFBQTVCLENBQVFLLGVBQVI7O0FBQ0Esa0JBQTRCLHFCQUFTQSxlQUFlLENBQUNLLFNBQWhCLEVBQVQsQ0FBNUI7QUFBQTtBQUFBLE1BQU9DLE1BQVA7QUFBQSxNQUFlQyxTQUFmOztBQUVBLDRCQUFTUCxlQUFULEVBQTBCLGVBQTFCLEVBQTJDO0FBQUEsV0FBTU8sU0FBUyxDQUFDUCxlQUFlLENBQUNLLFNBQWhCLEVBQUQsQ0FBZjtBQUFBLEdBQTNDO0FBRUEsTUFBTUcsT0FBTyxHQUFHLG9CQUFRO0FBQUEsV0FBTztBQUM3QmIsTUFBQUEsUUFBUSxFQUFSQSxRQUQ2QjtBQUU3QkksTUFBQUEsVUFBVSxFQUFWQSxVQUY2QjtBQUc3Qk8sTUFBQUEsTUFBTSxFQUFOQTtBQUg2QixLQUFQO0FBQUEsR0FBUixFQUlaLENBQUNYLFFBQUQsRUFBV0ksVUFBWCxFQUF1Qk8sTUFBdkIsQ0FKWSxDQUFoQjtBQU1BLHNCQUNFLGdDQUFDLG1CQUFELENBQVMsUUFBVDtBQUFrQixJQUFBLEtBQUssRUFBR0U7QUFBMUIsS0FFSSxPQUFPZixRQUFQLEtBQW9CLFVBQXBCLGdCQUNFLGdDQUFDLG1CQUFELENBQVMsUUFBVCxRQUNJLFVBQUFlLE9BQU87QUFBQSxXQUFJZixRQUFRLENBQUNlLE9BQUQsQ0FBWjtBQUFBLEdBRFgsQ0FERixHQUtFZixRQVBOLENBREY7QUFZRCxDQXJDRDs7QUF1Q0FGLFFBQVEsQ0FBQ2tCLFlBQVQsR0FBd0I7QUFDdEJoQixFQUFBQSxRQUFRLEVBQUVpQixTQURZO0FBRXRCZixFQUFBQSxRQUFRLEVBQUVlO0FBRlksQ0FBeEI7QUFLQW5CLFFBQVEsQ0FBQ29CLFNBQVQsR0FBcUI7QUFDbkJsQixFQUFBQSxRQUFRLEVBQUVtQixzQkFBVUMsR0FERDtBQUVuQmxCLEVBQUFBLFFBQVEsRUFBRWlCLHNCQUFVRSxLQUFWLENBQWdCO0FBQ3hCZCxJQUFBQSxlQUFlLEVBQUVZLHNCQUFVQyxHQURIO0FBRXhCVixJQUFBQSx3QkFBd0IsRUFBRVMsc0JBQVVDO0FBRlosR0FBaEI7QUFGUyxDQUFyQjtlQVFldEIsUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBDb250ZXh0IGZyb20gJy4vQ29udGV4dCc7XG5pbXBvcnQgY3JlYXRlU3ludGhlc2l6ZSBmcm9tICcuL2NyZWF0ZVN5bnRoZXNpemUnO1xuaW1wb3J0IG1pZ3JhdGVEZXByZWNhdGVkUHJvcHMgZnJvbSAnLi9taWdyYXRlRGVwcmVjYXRlZFByb3BzJztcbmltcG9ydCB1c2VFdmVudCBmcm9tICcuL3VzZUV2ZW50JztcblxuY29uc3QgQ29tcG9zZXIgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIHBvbnlmaWxsOiBwb255ZmlsbEZyb21Qcm9wcyB9ID0gbWlncmF0ZURlcHJlY2F0ZWRQcm9wcyhwcm9wcywgQ29tcG9zZXIpO1xuXG4gIC8vIElmIHdlIGhhdmUgdGhlIHBhcmVudCBjb250ZXh0LCB3ZSB3aWxsIHVzZSB0aGF0IHN5bnRoZXNpemUoKSBmdW5jdGlvbiBhbmQgaXRzIGludGVybmFsIHF1ZXVlLlxuICBjb25zdCB7IHBvbnlmaWxsOiBwYXJlbnRQb255ZmlsbCwgc3ludGhlc2l6ZTogcGFyZW50U3ludGhlc2l6ZSB9ID0gdXNlQ29udGV4dChDb250ZXh0KSB8fCB7fTtcblxuICBjb25zdCBwb255ZmlsbCA9IHBvbnlmaWxsRnJvbVByb3BzIHx8IHBhcmVudFBvbnlmaWxsIHx8IHtcbiAgICBzcGVlY2hTeW50aGVzaXM6IHdpbmRvdy5zcGVlY2hTeW50aGVzaXMgfHwgd2luZG93LndlYmtpdFNwZWVjaFN5bnRoZXNpcyxcbiAgICBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2U6IHdpbmRvdy5TcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UgfHwgd2luZG93LndlYmtpdFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSxcbiAgfTtcblxuICAvLyBJZiB0aGUgcGFyZW50IGNvbnRleHQgY2hhbmdlZCBhbmQgbm8gbG9uZ2VyIGhhcyBhIHN5bnRoZXNpemUoKSBmdW5jdGlvbiwgd2Ugd2lsbCBjcmVhdGUgdGhlIHF1ZXVlLlxuICAvLyBUaGlzIGlzIHZlcnkgdW5saWtlbHkgdG8gaGFwcGVuLlxuICBjb25zdCBzeW50aGVzaXplID0gdXNlTWVtbygoKSA9PiBwYXJlbnRTeW50aGVzaXplIHx8IGNyZWF0ZVN5bnRoZXNpemUoKSwgW3BhcmVudFN5bnRoZXNpemVdKTtcbiAgY29uc3QgeyBzcGVlY2hTeW50aGVzaXMgfSA9IHBvbnlmaWxsO1xuICBjb25zdCBbdm9pY2VzLCBzZXRWb2ljZXNdID0gdXNlU3RhdGUoc3BlZWNoU3ludGhlc2lzLmdldFZvaWNlcygpKTtcblxuICB1c2VFdmVudChzcGVlY2hTeW50aGVzaXMsICd2b2ljZXNjaGFuZ2VkJywgKCkgPT4gc2V0Vm9pY2VzKHNwZWVjaFN5bnRoZXNpcy5nZXRWb2ljZXMoKSkpO1xuXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcG9ueWZpbGwsXG4gICAgc3ludGhlc2l6ZSxcbiAgICB2b2ljZXNcbiAgfSksIFtwb255ZmlsbCwgc3ludGhlc2l6ZSwgdm9pY2VzXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17IGNvbnRleHQgfT5cbiAgICAgIHtcbiAgICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgIHsgY29udGV4dCA9PiBjaGlsZHJlbihjb250ZXh0KSB9XG4gICAgICAgICAgPC9Db250ZXh0LkNvbnN1bWVyPlxuICAgICAgICA6XG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgIH1cbiAgICA8L0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5Db21wb3Nlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gIHBvbnlmaWxsOiB1bmRlZmluZWRcbn07XG5cbkNvbXBvc2VyLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gIHBvbnlmaWxsOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHNwZWVjaFN5bnRoZXNpczogUHJvcFR5cGVzLmFueSxcbiAgICBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2U6IFByb3BUeXBlcy5hbnlcbiAgfSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvc2VyO1xuIl19